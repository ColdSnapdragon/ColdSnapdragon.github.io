<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Golang底层初涉(慕课) | 四方.io</title><meta name="author" content="Blover"><meta name="copyright" content="Blover"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第三章go的特点    一次编码 一次编译 不需要运行环境 没有虚拟化损失 不需要自行处理 GC 面向对象 非常易用的并发能力    C X √ X √ X X X   C++ X √ X √ X √ X   Java √ X √ X √ √ X   JavaScript √ O √ X √ √ X   Go √ X √ √ √ √ √   查看从代码到SSA中间码的整个过程1$env:GOSSA">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang底层初涉(慕课)">
<meta property="og:url" content="http://example.com/2023/10/29/Golang%E5%BA%95%E5%B1%82%E5%88%9D%E6%B6%89-%E6%85%95%E8%AF%BE/index.html">
<meta property="og:site_name" content="四方.io">
<meta property="og:description" content="第三章go的特点    一次编码 一次编译 不需要运行环境 没有虚拟化损失 不需要自行处理 GC 面向对象 非常易用的并发能力    C X √ X √ X X X   C++ X √ X √ X √ X   Java √ X √ X √ √ X   JavaScript √ O √ X √ √ X   Go √ X √ √ √ √ √   查看从代码到SSA中间码的整个过程1$env:GOSSA">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/cover/Golang.jpg">
<meta property="article:published_time" content="2023-10-29T13:53:24.000Z">
<meta property="article:modified_time" content="2023-10-29T14:01:56.820Z">
<meta property="article:author" content="Blover">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="课堂笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/cover/Golang.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/10/29/Golang%E5%BA%95%E5%B1%82%E5%88%9D%E6%B6%89-%E6%85%95%E8%AF%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Golang底层初涉(慕课)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-29 22:01:56'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/loading.gif" data-original="/images/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/Golang.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="四方.io"></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Golang底层初涉(慕课)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-29T13:53:24.000Z" title="发表于 2023-10-29 21:53:24">2023-10-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-29T14:01:56.820Z" title="更新于 2023-10-29 22:01:56">2023-10-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Golang底层初涉(慕课)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="go的特点"><a href="#go的特点" class="headerlink" title="go的特点"></a>go的特点</h2><table>
<thead>
<tr>
<th></th>
<th>一次编码</th>
<th>一次编译</th>
<th>不需要运行环境</th>
<th>没有虚拟化损失</th>
<th>不需要自行处理 GC</th>
<th>面向对象</th>
<th>非常易用的并发能力</th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td>X</td>
<td>√</td>
<td>X</td>
<td>√</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>C++</td>
<td>X</td>
<td>√</td>
<td>X</td>
<td>√</td>
<td>X</td>
<td>√</td>
<td>X</td>
</tr>
<tr>
<td>Java</td>
<td>√</td>
<td>X</td>
<td>√</td>
<td>X</td>
<td>√</td>
<td>√</td>
<td>X</td>
</tr>
<tr>
<td>JavaScript</td>
<td>√</td>
<td>O</td>
<td>√</td>
<td>X</td>
<td>√</td>
<td>√</td>
<td>X</td>
</tr>
<tr>
<td>Go</td>
<td>√</td>
<td>X</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h2 id="查看从代码到SSA中间码的整个过程"><a href="#查看从代码到SSA中间码的整个过程" class="headerlink" title="查看从代码到SSA中间码的整个过程"></a>查看从代码到SSA中间码的整个过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$env:GOSSAFUNC=&quot;main&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOSSAFUNC=main</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build</span><br></pre></td></tr></table></figure>

<h2 id="查看-Plan9-汇编代码"><a href="#查看-Plan9-汇编代码" class="headerlink" title="查看 Plan9 汇编代码"></a>查看 Plan9 汇编代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags -S main.go</span><br></pre></td></tr></table></figure>

<h2 id="使用-Modules"><a href="#使用-Modules" class="headerlink" title="使用 Modules"></a>使用 Modules</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/Jeffail/tunny </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/Jeffail/tunny@0.1.3 #指定版本</span><br></pre></td></tr></table></figure>

<h2 id="使用goproxy-cn作为代理"><a href="#使用goproxy-cn作为代理" class="headerlink" title="使用goproxy.cn作为代理"></a>使用goproxy.cn作为代理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>

<h2 id="go-mod-文件追加"><a href="#go-mod-文件追加" class="headerlink" title="go.mod 文件追加"></a>go.mod 文件追加</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace github.com/Jeffail/tunny =&gt; xxx/xxx # 替代为本地的路径，而不是到远程拉取</span><br></pre></td></tr></table></figure>

<h2 id="go-vender-缓存到本地"><a href="#go-vender-缓存到本地" class="headerlink" title="go vender 缓存到本地"></a>go vender 缓存到本地</h2><p>执行命令”go mod vendor”会将项目依赖的包下载到本地并保存在项目的vendor目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod vendor # 把依赖的包一次性缓存到本地</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -mod vendor # 执行本地缓存的包，不会去远程拉取</span><br></pre></td></tr></table></figure>

<h2 id="创建-Go-Module"><a href="#创建-Go-Module" class="headerlink" title="创建 Go Module"></a>创建 Go Module</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init github.com/imooc/moody</span><br></pre></td></tr></table></figure>



<h2 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h2><p><strong>go的runtime</strong></p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230806232618671.png" alt="image-20230806232618671"></p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230806232450975.png" alt="image-20230806232450975"></p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230806232509495.png" alt="image-20230806232509495"></p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230806233245351.png" alt="image-20230806233245351"></p>
<p>runtime.a永远会一起链接进可执行程序</p>
<p>g0是第一个启动的协程，g0是为了调度协程而产生的协程。随后创建一个主协程，执行用户的main方法。</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230807130304611.png" alt="image-20230807130304611"></p>
<h2 id="GO是面向对象吗？"><a href="#GO是面向对象吗？" class="headerlink" title="GO是面向对象吗？"></a>GO是面向对象吗？</h2><p>——官方回答：**”Yes and No”**</p>
<ul>
<li>Go允许OO的编程风格</li>
<li>Go的Struct可以看作其他语言的Class</li>
<li>Go缺乏其他语言的继承结构（平时用的“继承方法”那是另一回事）</li>
<li>Go的接口与其他语言有很大差异</li>
</ul>
<p>Go的继承</p>
<ul>
<li>Go并没有继承关系</li>
<li>所谓Go的继承只是组合</li>
<li>组合中的匿名字段，通过语法糖达成了类以继承的效果</li>
</ul>
<p>总结</p>
<p>◆Go没有对象、没有类、没有继承<br>◆Go通过组合匿名字段来达到类似继承的效果<br>◆通过以上手段去掉了面向对象中复杂而冗余的部分<br>◆保留了基本的面向对象特性</p>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="基本类型大小"><a href="#基本类型大小" class="headerlink" title="基本类型大小"></a>基本类型大小</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i := <span class="number">1234</span> <span class="comment">// golang中int(和uint)的大小与系统有关，在64位系统上，其大小为8字节</span></span><br><span class="line">    j:= <span class="type">int32</span>(<span class="number">1</span>)</span><br><span class="line">    f:=<span class="type">float32</span>(<span class="number">3.141</span>)</span><br><span class="line">    bytes := [<span class="number">5</span>]<span class="type">byte</span>&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line">    primes := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;</span><br><span class="line">    p:= &amp;primes</span><br><span class="line"></span><br><span class="line">    r:= <span class="type">rune</span>(<span class="number">666</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Println(unsafe.Sizeof(i))</span><br><span class="line">    fmt.Println(unsafe.Sizeof(j))</span><br><span class="line">    fmt.Println(unsafe.Sizeof(f))</span><br><span class="line">    fmt.Println(unsafe.Sizeof(bytes))</span><br><span class="line">    fmt.Println(unsafe.Sizeof(primes))</span><br><span class="line">    fmt.Println(unsafe.Sizeof(p))</span><br><span class="line">    fmt.Println(unsafe.Sizeof(r))</span><br><span class="line">    fmt.Println(unsafe.Sizeof(<span class="string">&quot;你好&quot;</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空结构体在内存中有地址而长度为0</strong>，所有的空结构体对象的地址都是一样的。（除非被嵌套在其它结构体中）</p>
<p>runtime-malloc.go：</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230807141527937.png" alt="image-20230807141527937"></p>
<p>字符串的底层是一个结构体，任何字符串实例的sizeof都是一样的（16字节）：</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230807143919396.png" alt="image-20230807143919396" style="zoom:67%;" />

<h2 id="字符串转StringHeader"><a href="#字符串转StringHeader" class="headerlink" title="字符串转StringHeader"></a>字符串转StringHeader</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    str := <span class="string">&quot;你a&quot;</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> str &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;unicode: %c %d %T\n&quot;</span>, s, s, s)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;ascii: %c %d %T\n&quot;</span>, str[i], str[i], str[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串的两种遍历"><a href="#字符串的两种遍历" class="headerlink" title="字符串的两种遍历"></a>字符串的两种遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;快乐 everyday&quot;</span></span><br><span class="line"></span><br><span class="line">str1 := str[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> str1&#123; <span class="comment">// range可以自动解码utf-8</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;unicode: %c %d %T\n&quot;</span>, s,s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(str1) ;i++  &#123; <span class="comment">// 下标访问时不会解码</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;ascii: %c %d %T\n&quot;</span>, str[i], str[i])</span><br></pre></td></tr></table></figure>

<p>字符串的访问<br>◆对字符串使用len方法得到的是字节数不是字符数<br>◆对字符串直接使用下标访问，得到的是字节<br>◆字符串被range遍历时，被解码成rune类型的字符<br>◆UTF-8编码解码算法位于runtime&#x2F;utf8.go</p>
<p>使用utf-8变长编码的字符串时，怎么切分含中英文的字符串呢？以取前三个字符为例：</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230807144655482.png" alt="image-20230807144655482" style="zoom:67%;" />

<h2 id="切片的三种创建方式"><a href="#切片的三种创建方式" class="headerlink" title="切片的三种创建方式"></a>切片的三种创建方式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>:<span class="number">3</span>] or slice[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>切片的sizeof总是24（比字符串多一个cap）</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230807165543546.png" alt="image-20230807165543546"></p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230807165244738.png" alt="image-20230807165244738" style="zoom:67%;" />

<p>比如a&#x3D;[1,2]，然后append(a,1,2,3,4)，此时期望容量大于原容量的两倍。</p>
<p>map的底层结构：</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230807221723450.png" alt="image-20230807221723450"></p>
<p>unsafe.Pointer为<strong>万能指针</strong>，指向任意对象。</p>
<p>非溢出桶的数量为2^B。桶内的元素，其key的哈希值相同。通过种子（hash0）的到一个值，对2^B取余得到桶号。tophash的计算如下（取最前的8位）：</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230807231714812.png" alt="image-20230807231714812"></p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230807232153844.png" alt="image-20230807232153844"></p>
<p>tophash、keys和elems是三个数组。overflow指向溢出桶。</p>
<p>如果tophash碰撞得比较厉害，就继续顺序往下找（包括到溢出桶去找）。</p>
<p>总结：<br>◆Go语言使用拉链实现了hashmap<br>◆每一个桶中存储键哈希的前8位<br>◆桶超出8个数据，就会存储到溢出桶中</p>
<h2 id="map的扩容"><a href="#map的扩容" class="headerlink" title="map的扩容"></a>map的扩容</h2><ul>
<li><p>map溢出桶太多时会导致严重的性能下降</p>
</li>
<li><p>runtime.mapassign(0可能会触发扩容的情况：</p>
<ul>
<li>装载因子超过6.5（平均每个槽6.5个ky)</li>
<li>使用了太多溢出桶（溢出桶成了一条链表，超过了普通桶）</li>
</ul>
</li>
</ul>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230807233207132.png" alt="image-20230807233207132" style="zoom:50%;" />

<p>步骤1</p>
<p>创建一组新桶<br>oldbuckets指向原有的桶数组<br>buckets指向新的桶数组<br>map标记为扩容状态</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230807233400968.png" alt="image-20230807233400968" style="zoom:67%;" />

<p>步骤2</p>
<p>将所有的数据从旧桶<strong>驱逐</strong>到新桶<br>采用渐进式驱逐<br>每次操作一个旧桶时，将旧桶数据驱逐到新桶<br>读取时不进行驱逐，只判断读取新桶还是引旧桶</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230807233455928.png" alt="image-20230807233455928"></p>
<p>B的值加1，某个旧桶的数据会被<strong>驱逐</strong>到最多两个新桶中（根据新桶号）</p>
<p>步骤3</p>
<p>所有的旧桶驱逐完成后，oldbuckets回收</p>
<p><strong>map采用的是增量扩容</strong>，它通过每一次的 map 操作行为去分摊总的一次性动作。（详细自行了解）</p>
<h2 id="map的并发问题"><a href="#map的并发问题" class="headerlink" title="map的并发问题"></a>map的并发问题</h2><p>提前<strong>总结</strong><br><strong>◆map在扩容时会有并发问题</strong><br><strong>◆sync.Map使用了两个map,分离了扩容问题</strong><br><strong>◆不会引发扩容的操作（查、改）使用read map</strong><br><strong>◆可能引发扩容的操作（新增）使用dirty map</strong></p>
<p>如果在程序运行中，发生对一个map出现并发冲突，那么会直接爆异常。也就是非并发安全的map选择了干脆<strong>禁止同时读写</strong>（读写分离）。<strong>map的并发问题主要集中在扩容时的影响</strong>。</p>
<p>map并发问题解决方案</p>
<ul>
<li><strong>给map加锁(mutex)</strong></li>
<li><strong>使用sync.Map</strong></li>
</ul>
<p>给map加锁的话，会严重影响程序的并发性，go为我们提供了sync.Map。（适用于追加少。如果经常追加那么其实和map加锁差不多）</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230808010204157.png" alt="image-20230808010204157"></p>
<p>万能指针是entry的唯一成员。<code>amended</code>表示“追加”，是一个布尔值。上图演示了把<code>a:A</code>改成<code>a:AAA</code>的过程。</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230808010836693.png" alt="image-20230808010836693"></p>
<p>此过程如下：</p>
<ol>
<li>read-map中找不到key为<code>d</code></li>
<li><code>amended</code>置为<code>true</code>，并给dirty加锁（图中<code>mu</code>的作用）</li>
<li>在dirty追加数据，完毕后释放锁</li>
</ol>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230808011109170.png" alt="image-20230808011109170"></p>
<p>此过程如下：</p>
<ol>
<li>read-map中找不到key为<code>d</code></li>
<li>发现<code>amended</code>为<code>true</code>，去dirty查找</li>
<li>在dirty找到了数据，然后给<code>misses</code>（<strong>未命中</strong>）加1</li>
<li>如果<code>misses</code>达到了<code>len(dirty)</code>，则作dirty提升。</li>
</ol>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230808011359279.png" alt="image-20230808011359279"><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230808011456410.png" alt="image-20230808011456410"></p>
<p><code>misses</code>置0，<code>amended</code>置<code>false</code>。当再次需要dirty时，才会重建dirty。</p>
<p>正常通过read-map进行删除时没问题的。问题出在追加后删除，关键在于提升dirty时的问题。</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230808012331592.png" alt="image-20230808012331592"><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230808012349707.png" alt="image-20230808012349707"></p>
<h2 id="Go隐式接口特点"><a href="#Go隐式接口特点" class="headerlink" title="Go隐式接口特点"></a>Go隐式接口特点</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> taxi <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t taxi)</span></span> Drive() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Drive taxi&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t taxi)</span></span> MakeMoney() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Make Money&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">interface</span> &#123;</span><br><span class="line">    Drive()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MoneyMaker <span class="keyword">interface</span> &#123;</span><br><span class="line">    MakeMoney()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230808133919281.png" alt="image-20230808133919281" style="zoom: 50%;" />

<p><strong>iface记录了“类型”与“数据”。只有当这两个属性都为nil时，接口才为nil。</strong></p>
<p>空接口的底层跟普通接口不一样，空接口的底层是eface结构体。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809154032129.png" alt="image-20230809154032129" style="zoom: 50%;" />

<p>当使用结构体作为方法的receiver时，会自动再生成一个以对应结构体的指针作为recevier的方法（如下图），<strong>而反之则没有</strong>，在实现接口时要注意这一点。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809154309595.png" alt="image-20230809154309595" style="zoom: 80%;" />

<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><ul>
<li>nil是空，并不一定是”空指针”</li>
<li><strong>nil是6种类型的”零值”</strong></li>
<li>每种类型的nil是不同的，无法比较</li>
</ul>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809162429720.png" alt="image-20230809162429720"></p>
<p>可见不包括结构体，这表明任何结构体实例都不等于nil（即使是空结构体）。</p>
<p>以上定义在builtin包里，这个包表示“内置”，定义了许多我们熟知的类型：</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809162651901.png" alt="image-20230809162651901"></p>
<h2 id="结构体和指针实现接口"><a href="#结构体和指针实现接口" class="headerlink" title="结构体和指针实现接口"></a>结构体和指针实现接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Car <span class="keyword">interface</span> &#123;</span><br><span class="line">    Drive()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> truck <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *truck)</span></span> Drive() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a Car = truck&#123;&#125;</span><br><span class="line">    fmt.Println(reflect.TypeOf(a))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="变量对齐"><a href="#变量对齐" class="headerlink" title="变量对齐"></a>变量对齐</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">    num1 <span class="type">int32</span></span><br><span class="line">    num2 <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Flag <span class="keyword">struct</span> &#123;</span><br><span class="line">    num1 <span class="type">int16</span></span><br><span class="line">    num2 <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(unsafe.Sizeof(Args&#123;&#125;))</span><br><span class="line">    fmt.Println(unsafe.Sizeof(Flag&#123;&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">unsafe.Alignof(Args&#123;&#125;) <span class="comment">// 8</span></span><br><span class="line">unsafe.Alignof(Flag&#123;&#125;) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;bool size:%d align: %d\n&quot;</span>, unsafe.Sizeof(<span class="type">bool</span>(<span class="literal">true</span>)), unsafe.Alignof(<span class="type">bool</span>(<span class="literal">true</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;byte size:%d align: %d\n&quot;</span>, unsafe.Sizeof(<span class="type">byte</span>(<span class="number">0</span>)), unsafe.Alignof(<span class="type">byte</span>(<span class="number">0</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;int8 size:%d align: %d\n&quot;</span>, unsafe.Sizeof(<span class="type">int8</span>(<span class="number">0</span>)), unsafe.Alignof(<span class="type">int8</span>(<span class="number">0</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;int16 size:%d align: %d\n&quot;</span>, unsafe.Sizeof(<span class="type">int16</span>(<span class="number">0</span>)), unsafe.Alignof(<span class="type">int16</span>(<span class="number">0</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;int32 size:%d align: %d\n&quot;</span>, unsafe.Sizeof(<span class="type">int32</span>(<span class="number">0</span>)), unsafe.Alignof(<span class="type">int32</span>(<span class="number">0</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;int64 size:%d align: %d\n&quot;</span>, unsafe.Sizeof(<span class="type">int64</span>(<span class="number">0</span>)), unsafe.Alignof(<span class="type">int64</span>(<span class="number">0</span>)))</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<ul>
<li><p>Go中每一个变量都有自己的对齐系数</p>
<p>对齐系数的含义是：变量的内存地址必须被对齐系数整除<br><strong>如果对齐系数为4，表示变量内存地址必须是4的倍数</strong></p>
</li>
</ul>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809164302926.png" alt="image-20230809164302926" style="zoom:67%;" />

<p>字长（Word length）是指计算机处理数据的基本单元的位数，<strong>它表示计算机能够一次处理的二进制位数或字节数</strong>。以下以字长为64位（即八字节）为例。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809170335767.png" alt="image-20230809170335767" style="zoom:67%;" />

<p>假如非字长对齐，那么<strong>内存的原子性与效率受到影响</strong>。</p>
<p>对齐系数：（一般等于自身大小）</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809170548445.png" alt="image-20230809170548445"></p>
<p>string的大小为16，但对齐系数为8。每个成员的偏移量是自身大小与其对齐系数较小值的倍数。</p>
<p><strong>结构体既需要内部对齐，又需要外部填充对齐</strong>。</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809170714809.png" alt="image-20230809170714809"><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809170731018.png" alt="image-20230809170731018"></p>
<p>注意结构体中成员的顺序在内存中是严格的。</p>
<p><strong>结构体的对齐系数是其成员的最大对齐系数</strong>。</p>
<p><em><strong>空结构体</strong></em></p>
<ol>
<li>空结构体单独出现时，地址为zerobase</li>
<li>空结构体出现在结构体中时，地址跟随前一个变量</li>
<li>空结构体出现在结构体末尾时，需要补齐字长</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Demo <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">bool</span></span><br><span class="line">    z <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    c <span class="type">int16</span></span><br><span class="line">    b <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809171101156.png" alt="image-20230809171101156" style="zoom:67%;" />

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Demo <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">bool</span></span><br><span class="line">    c <span class="type">int16</span></span><br><span class="line">    b <span class="type">string</span></span><br><span class="line">    z <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809171245130.png" alt="image-20230809171245130" style="zoom:67%;" />

<p>这是为了防止内存分配的下一个变量的地址与z撞车。</p>
<h2 id="字长对齐"><a href="#字长对齐" class="headerlink" title="字长对齐"></a>字长对齐</h2><ul>
<li>对于特定系统，也有系统对齐系数，一般为系统字长</li>
<li>变量要尽量放置在一个系统字长里</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int16</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;c)</span><br></pre></td></tr></table></figure>

<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="5-2节代码"><a href="#5-2节代码" class="headerlink" title="5-2节代码"></a>5-2节代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;dododo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	do3()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	do2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="协程本质"><a href="#协程本质" class="headerlink" title="协程本质"></a>协程本质</h2><blockquote>
<p>关于协程，我觉得这篇<a target="_blank" rel="noopener" href="https://www.cnblogs.com/theRhyme/p/14061698.html">协程的原理以及与线程的区别 - rhyme - 博客园 (cnblogs.com)</a>讲挺好的。</p>
</blockquote>
<p>协程<br>◆协程就是将一段程序的运行状态打包，可以在线程之间调度<br>◆将生产流程打包，使得流程不固定在生产线上<br>◆协程并不取代线程，<strong>协程也要在线程上运行</strong><br>◆线程是协程的资源，协程使用线程这个资源</p>
<p>协程的优势<br>◆资源利用<br>◆快速调度<br>◆超高并发</p>
<p>协程的底层结构（因为协程本身就是go程序去管）</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809203530281.png" alt="image-20230809203530281"></p>
<ul>
<li>runtime中，协程的本质是一个g结构体</li>
<li>stack:堆栈地址</li>
<li>gobuf:目前程序运行现场</li>
<li>atomicstatus:协程状态</li>
</ul>
<p>下图展示了g结构体的一些关键部分：</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809202942888.png" alt="image-20230809202942888"></p>
<p>每个goroutine有自己的栈空间。</p>
<p>通过sp得知执行到哪个函数了，通过pc得知执行到哪一行了。</p>
<p>m结构体：（线程归内核管，只记录了线程的信息）（比如当前执行的协程为哪一个）</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809203556171.png" alt="image-20230809203556171"></p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230809203421271.png" alt="image-20230809203421271" style="zoom: 67%;" />

<h2 id="协程工作"><a href="#协程工作" class="headerlink" title="协程工作"></a>协程工作</h2><p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810172509774.png" alt="image-20230810172509774"></p>
<p>过程如下：</p>
<ol>
<li>线程一开始进入的是g0的协程栈，执行其schedule方法</li>
<li>schedule找到一个可执行的协程g，传给execute函数</li>
<li>execute函数做了一些初始化工作，随后进入gogo函数</li>
<li>gogo函数是汇编实现的，它向g中人为地在函数栈中插入一段<code>goexit函数</code>，这是为了最后返回到此函数中</li>
<li>gogo函数随后根据sp和pc，从协程的某个位置继续执行</li>
<li>返回到goexit函数后，该函数将线程的调用栈切换回g0</li>
</ol>
<p>注意<strong>上述这个过程始终是运行在线程上的</strong>。为了适应多核，后来又加入了多线程循环。</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810172721279.png" alt="image-20230810172721279"></p>
<p>&#x3D;&#x3D;<code>runnable queue</code>&#x3D;&#x3D;（可用协程队列）需要加锁。</p>
<p>总结-线程循环<br>◆操作系统并不知道Goroutine的存在<br>◆操作系统线程执行一个调度循环，顺序执行Goroutine<br>◆调度循环非常像线程池</p>
<p>问题<br>◆协程顺序执行，无法并发<br>◆多线程并发时，会抢夺协程队列的全局锁</p>
<h2 id="GMP调度模型"><a href="#GMP调度模型" class="headerlink" title="GMP调度模型"></a>GMP调度模型</h2><p>GMP调度模型旨在解决上述第二个问题。</p>
<p>GMP对应了g, m, p三个结构体。p是processer的简称，p结构体内含有指向其服务的m的指针，以及一个储存g结构体指针的<strong>本地队列</strong>。m可以<strong>无锁</strong>从本地队列中取出可用协程。runnext指向队列中的下一个可用协程。</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810175427210.png" alt="image-20230810175427210"></p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810175134708.png" alt="image-20230810175134708" style="zoom:67%;" />

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810175705388.png" alt="image-20230810175705388" style="zoom:67%;" />

<p>当P中的协程用完时，会到全局队列中<strong>批量获取</strong>协程，该过程仍需要获取锁。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810175108875.png" alt="image-20230810175108875" style="zoom:67%;" />

<p>任务窃取：如果M在本地或者全局队列中都找不到可用G，去别的P中“偷”，这样增强了线程的利用率。</p>
<p>新建协程<br>◆随机寻找一个P<br>◆将新协程放入P的runnext(插队)（优先执行新建协程）<br>◆若P本地队列满，放入全局队列</p>
<h2 id="协程并发"><a href="#协程并发" class="headerlink" title="协程并发"></a>协程并发</h2><p>◆如果协程顺序执行，会有饥饿问题<br>◆协程执行中间，将协程挂起，执行其他协程<br>◆完成系统调用时挂起，也可以主动挂起<br>◆防止全局队列饥饿，本地队列随机抽取全局队列</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810181103251.png" alt="image-20230810181103251"></p>
<p>这里放回的是本地队列，但这样可能会引起全局队列中的协程饥饿。</p>
<p>go底层源码的解决方法是：每从P结构体的队列拿61个协程以后，就到全局队列去拿一个。</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810181518763.png" alt="image-20230810181518763"></p>
<p>切换时机：</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810181301271.png" alt="image-20230810181301271" style="zoom:67%;" />

<p>系统调用结束时会挂起。</p>
<p>主动挂起不是说自己调用gopark函数（注意小写字母开头）。像Sleep这样的函数底层就调用了gopark。</p>
<h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><p><strong>基于协作的抢占式调度</strong></p>
<p><strong>问题</strong>——如果程序：</p>
<p>◆永远都不主动挂起<br>◆永远都不系统调用</p>
<p>那么便不能及时切换。考虑到有什么过程会在程序中被经常调用，go为<code>morestack函数</code>赋予了其他功能</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810183044264.png" alt="image-20230810183044264"></p>
<p>调用函数时，需要先通过morestack函数来检查协程栈是否充足。同时，<code>morestack</code>会检查协程是否处于被标记抢占（系统监控器负责）的状态，如果是，回到schedule()。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810183324278.png" alt="image-20230810183324278" style="zoom:67%;" />

<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810183436539.png" alt="image-20230810183436539"></p>
<p><strong>问题：</strong>以下代码无法切换协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">s</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go将SIGURG（紧急信号）用作调度用途。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810193831160.png" alt="image-20230810193831160" style="zoom:67%;" />

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810193954289.png" alt="image-20230810193954289" style="zoom:67%;" />



<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230810182718456.png" alt="image-20230810182718456" style="zoom:67%;" />

<h2 id="无限开启协程"><a href="#无限开启协程" class="headerlink" title="无限开启协程"></a>无限开启协程</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="利用-channel-的缓存区"><a href="#利用-channel-的缓存区" class="headerlink" title="利用 channel 的缓存区"></a>利用 channel 的缓存区</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">30000</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; math.MaxInt32; i++ &#123;</span><br><span class="line">		ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			log.Println(i)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			&lt;-ch</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Hour)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此代码会因为并发操作数量过多而在运行中爆panic。</p>
<h2 id="协程池"><a href="#协程池" class="headerlink" title="协程池"></a>协程池</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">go get github.com/Jeffail/tunny</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool := tunny.NewFunc(<span class="number">3000</span>, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        log.Println(i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">defer</span> pool.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> pool.Process(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>老师并不推荐用协程池（因为go的协程调度已经够池化了。◆Go语言的初衷是希望协程即用即毁，不要池化）</p>
<p>协程太多的问题<br>◆文件打开数限制<br>◆内存限制<br>◆调度开销过大</p>
<p>总结<br>◆太多的协程会给程序运行带来性能和稳定性问题<br>◆牺牲并发特性，利用channe|缓冲</p>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="Atomic-机制"><a href="#Atomic-机制" class="headerlink" title="Atomic 机制"></a>Atomic 机制</h2><ul>
<li>CPU 级别支持的原子操作</li>
<li>X86平台：给内存加锁，再操作</li>
<li>Arm平台：先操作，如果操作失败，再重试</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(p *<span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">	*p++</span><br><span class="line"></span><br><span class="line">	<span class="comment">//*p = *p + 1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//atomic.AddInt32(p, 1)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> add(&amp;c)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923140059039.png" alt="image-20230923140059039" style="zoom:67%;" />

<p>atomic操作运用了硬件层面锁</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923140124995.png" alt="image-20230923140124995"></p>
<p><strong>CAS</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok = atomic.CompareAndSwapInt32(&amp;value, value, newValue)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Go语言中，CAS（Compare and Swap）是一种原子操作，用于实现并发安全的内存访问。CAS操作由<code>sync/atomic</code>包提供，它允许你比较一个内存地址的值与旧值，并在相等时将新值写入该地址。CAS操作可以用于实现<strong>无锁的并发算法</strong>，如自旋锁、无锁队列（应用在头和尾指针的Swap中）等。</p>
<p>CAS操作在并发环境中通常包含以下步骤：</p>
<ol>
<li>读取内存地址的当前值。</li>
<li>比较当前值与期望的旧值。如果它们相等，说明内存地址的值没有被其他线程修改，可以进行更新操作。</li>
<li>如果当前值与旧值相等，则将新值写入内存地址。</li>
<li>如果当前值与旧值不相等，则说明其他线程已经修改了内存地址的值，CAS操作失败，需要重新尝试。</li>
</ol>
<p>CAS操作是原子的，意味着它在执行期间不会被其他线程中断。如果多个线程同时尝试执行CAS操作，只有一个线程能够成功，其他线程需要重新尝试或执行其他操作。</p>
</blockquote>
<h2 id="sema锁"><a href="#sema锁" class="headerlink" title="sema锁"></a>sema锁</h2><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923134634499.png" alt="image-20230923134634499" style="zoom:50%;" />

<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923134514184.png" alt="image-20230923134514184"></p>
<p>底层仍有atomic操作，Uint32是接下去的重点。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923134537378.png" alt="image-20230923134537378" style="zoom:67%;" />

<p>treap指针指着一颗平衡二叉树。二叉树的每个节点是一个sudog结构体，每个结构体内对应有一个协程（g结构体）。</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923134729269.png" alt="image-20230923134729269"></p>
<blockquote>
<p>sema操作(uint32&gt;0)<br>获取锁：uint32<strong>减一</strong>，获取成功<br>释放锁：uint32<strong>加一</strong>，释放成功</p>
</blockquote>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923135352816.png" alt="image-20230923135352816" style="zoom:67%;" />

<p>查看<code>semacquire1</code>函数。sema锁的uint32值为0时，协程会加入二叉树并阻塞在以下这一步（s是当前协程的sudog）——</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923135723360.png" alt="image-20230923135723360"></p>
<blockquote>
<p><strong>总结</strong><br>原子操作是一种硬件层面加锁的机制<br>数据类型和操作类型有限制<br>sema锁是runtimel的常用工具<br>sema经常被用作休眠队列</p>
</blockquote>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>底层结构：</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923150041312.png" alt="image-20230923150041312"></p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923151451774.png" alt="image-20230923151451774" style="zoom:67%;" />

<p>WaiterShift表示阻塞在这把锁上的协程数量，占29位。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923150340781.png" alt="image-20230923150340781" style="zoom:67%;" />

<p>当锁被抢占时（即Locked为1），当前协程会尝试多次自旋（Spin），重复判断Locked，随后才去获取sema。</p>
<p>由于sema被配置为0，所有获取它的行为必然失败并导致进入二叉树休眠，相当于是一个等待队列。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923150537361.png" alt="image-20230923150537361" style="zoom:67%;" />

<p>WaiterShift加一。当锁被释放时，再从平衡二叉树唤醒一个休眠的协程。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923151130927.png" alt="image-20230923151130927" style="zoom:67%;" />

<p>被唤醒协程仍要和新来的协程继续竞争锁，这可能导致某些协程迟迟获取不到锁，造成饥饿现象。</p>
<p><strong>总结</strong><br>mutex正常模式：自旋加锁+sema休眠等待<br>mutex正常模式下，可能有锁饥饿的问题</p>
<h2 id="锁饥饿"><a href="#锁饥饿" class="headerlink" title="锁饥饿"></a>锁饥饿</h2><p>Starving位标志饥饿模式。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923151946726.png" alt="image-20230923151946726" style="zoom:67%;" />

<p><strong>总结</strong><br>锁竞争严重时，互斥锁进入饥饿模式<br>饥饿模式没有自旋等待，有利于公平</p>
<p><strong>优化经验</strong><br>减少锁的使用时间（减少粒度）<br>善用defer确保锁的释放<br><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230923154657676.png" alt="image-20230923154657676"></p>
<h2 id="读写锁的使用"><a href="#读写锁的使用" class="headerlink" title="读写锁的使用"></a>读写锁的使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu     sync.RWMutex</span><br><span class="line">	salary <span class="type">int</span></span><br><span class="line">	level  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">promote</span><span class="params">(p *Person)</span></span> &#123;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	p.salary++</span><br><span class="line">	fmt.Println(p.salary)</span><br><span class="line">	p.level++</span><br><span class="line">	fmt.Println(p.level)</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printPerson</span><span class="params">(p *Person)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> p.mu.RUnlock()</span><br><span class="line">	p.mu.RLock()</span><br><span class="line">	fmt.Println(p.salary)</span><br><span class="line">	fmt.Println(p.level)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	p := Person&#123;level: <span class="number">1</span>, salary: <span class="number">10000</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> promote(&amp;p)</span><br><span class="line">	<span class="keyword">go</span> promote(&amp;p)</span><br><span class="line">	<span class="keyword">go</span> promote(&amp;p)</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="waitgroup的使用"><a href="#waitgroup的使用" class="headerlink" title="waitgroup的使用"></a>waitgroup的使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu     sync.RWMutex</span><br><span class="line">	salary <span class="type">int</span></span><br><span class="line">	level  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">promote</span><span class="params">(p *Person, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	p.salary++</span><br><span class="line">	fmt.Println(p.salary)</span><br><span class="line">	p.level++</span><br><span class="line">	fmt.Println(p.level)</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printPerson</span><span class="params">(p *Person, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> p.mu.RUnlock()</span><br><span class="line">	p.mu.RLock()</span><br><span class="line">	fmt.Println(p.salary)</span><br><span class="line">	fmt.Println(p.level)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	p := Person&#123;level: <span class="number">1</span>, salary: <span class="number">10000</span>&#125;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">go</span> promote(&amp;p, &amp;wg)</span><br><span class="line">	<span class="keyword">go</span> promote(&amp;p, &amp;wg)</span><br><span class="line">	<span class="keyword">go</span> promote(&amp;p, &amp;wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230924014422700.png" alt="image-20230924014422700" style="zoom:67%;" />

<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230924014629366.png" alt="image-20230924014629366"></p>
<p>noCopy标志着此类型的实例不可复制，运行时会检查此值，在违规时报异常。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230924014523381.png" alt="image-20230924014523381" style="zoom:67%;" />

<p>waiter代表等待的协程数，counter代表正在运行的占有WaitGroup的协程数。<br>调用Wait方法后，会检查counter是否为0，然后产生不同的行为（见上）。</p>
<p><strong>总结</strong><br>WaitGroup实现了<strong>一组协程等待另一组协程</strong><br>等待的协程陷入sema并记录个数<br>被等待的协程计数归零时，唤醒所有sema中的协程</p>
<h2 id="锁拷贝问题"><a href="#锁拷贝问题" class="headerlink" title="锁拷贝问题"></a>锁拷贝问题</h2><ul>
<li>锁拷贝可能导致锁的死锁问题</li>
<li>使用 vet 工具可以检测锁拷贝问题</li>
<li>vet 还能检测可能的 bug 或者可疑的构造</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	m := sync.Mutex&#123;&#125;</span><br><span class="line">	n := m</span><br><span class="line">	fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go vet </span><br></pre></td></tr></table></figure>

<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230924021014862.png" alt="image-20230924021014862"></p>
<h2 id="RACE-竞争检测"><a href="#RACE-竞争检测" class="headerlink" title="RACE 竞争检测"></a>RACE 竞争检测</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> J <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> &#123;</span><br><span class="line">	J++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">200</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> do()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -race main.go</span><br></pre></td></tr></table></figure>

<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230924020803785.png" alt="image-20230924020803785"></p>
<p><strong>RACE竞争检测</strong></p>
<ul>
<li>发现隐含的数据竞争问题</li>
<li>可能是加锁的建议</li>
<li>可能是bug的提醒</li>
</ul>
<h2 id="dead-lock-检测"><a href="#dead-lock-检测" class="headerlink" title="dead lock 检测"></a>dead lock 检测</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	sync <span class="string">&quot;github.com/sasha-s/go-deadlock&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> J <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> M = sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> &#123;</span><br><span class="line">	M.Lock()</span><br><span class="line">	J++</span><br><span class="line">	time.Sleep(<span class="number">100000000000</span>)</span><br><span class="line">	M.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sync.Opts.DeadlockTimeout = time.Millisecond * <span class="number">100</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">200</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> do()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">10000000000000000</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>go-deadlock检测</strong>（这是一个github开源项目）</p>
<ul>
<li>检测可能的死锁</li>
<li>实际是检测获取锁的等待时间</li>
<li>用来排查bug和性能问题</li>
</ul>
<h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="Channel-声明方法"><a href="#Channel-声明方法" class="headerlink" title="Channel 声明方法"></a>Channel 声明方法</h2><ul>
<li>chInt :&#x3D; make(chan int)       &#x2F;&#x2F; unbuffered channel  非缓冲通道</li>
<li>chBool :&#x3D; make(chan bool, 0)  &#x2F;&#x2F; unbuffered channel  非缓冲通道</li>
<li>chStr :&#x3D; make(chan string, 2) &#x2F;&#x2F; bufferd channel     缓冲通道</li>
</ul>
<h2 id="Channel-基本用法"><a href="#Channel-基本用法" class="headerlink" title="Channel 基本用法"></a>Channel 基本用法</h2><ul>
<li>ch &lt;- x &#x2F;&#x2F; channel 接收数据 x</li>
<li>x &lt;- ch &#x2F;&#x2F; channel 发送数据并赋值给 x</li>
<li>&lt;- ch &#x2F;&#x2F; channel 发送数据，忽略接受者</li>
</ul>
<h2 id="错误用法"><a href="#错误用法" class="headerlink" title="错误用法"></a>错误用法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="string">&quot;ping&quot;</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="string">&quot;ping&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存与通信"><a href="#内存与通信" class="headerlink" title="内存与通信"></a>内存与通信</h2><ul>
<li>“不要通过共享内存的方式进行通信”</li>
<li>“而是应该通过通信的方式共享内存”</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(p *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> *p == <span class="number">1</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">go</span> watch(&amp;i)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> &lt;-c == <span class="number">1</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> watch(c)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>为什么使用channel来通信</strong></p>
<p>相对于无锁</p>
<ul>
<li>避免协程竞争和数据冲突的问题</li>
</ul>
<p>相对于加锁</p>
<ul>
<li>更高级的抽象，降低开发难度，增加程序可读性</li>
<li>模块之间更容易解耦，增强扩展性和可维护性</li>
</ul>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230901205515057.png" alt="image-20230901205515057" style="zoom:50%;" />

<p><strong>channel的底层结构</strong>：</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230901205426930.png" alt="image-20230901205426930"  /><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230901213642355.png" alt="image-20230901213642355" style="zoom: 67%;" /></p>
<p>前六行描述了一个缓存区（buf指针可能为空，表示为无缓存），后面的成员描述了两个队列。</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230901221426761.png" alt="image-20230901221426761">waitq包含了sudog结构体，表示被阻塞的协程。sudog中含有发送或接受的对象的地址。</p>
<blockquote>
<p>可以看到有一把互斥锁lock</p>
<p>互斥锁并不是排队发送&#x2F;接收数据<br>互斥锁保护的hchans结构体本身<br>Channel并不是无锁的</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230901205454171.png" alt="image-20230901205454171" style="zoom:40%;" /><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230901213721621.png" alt="image-20230901213721621" style="zoom:50%;" /></p>
<h2 id="发送和接受"><a href="#发送和接受" class="headerlink" title="发送和接受"></a>发送和接受</h2><blockquote>
<p>c&lt;-关键字是一个语法糖<br>编译阶段，会把c&lt;-转化为runtime.chansend1()<br>chansend1()会调用chansend0方法</p>
</blockquote>
<p><strong>发送情况</strong></p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230901221659852.png" alt="image-20230901221659852" style="zoom:50%;" />

<p>若接收队列为空，<strong>才把</strong>变量拷贝进缓存中的可用缓存单元。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230901221313436.png" alt="image-20230901221313436" style="zoom:50%;" />

<p>总结</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230901221845826.png" alt="image-20230901221845826" style="zoom:50%;" />



<p><strong>接受情况</strong></p>
<blockquote>
<p>&lt;-C关键字是一个语法糖<br>编译阶段，i&lt;-c转化为runtime.chanrecv1()<br>编译阶段，i,ok&lt;-c转化为runtime.chanrecv2()</p>
</blockquote>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230901223641381.png" alt="image-20230901223641381" style="zoom:50%;" />

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230901223535109.png" alt="image-20230901223535109" style="zoom:50%;" />

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230901223728749.png" alt="image-20230901223728749" style="zoom:50%;" />

<blockquote>
<p><strong>总结</strong></p>
<p>编译阶段，&lt;-c会转化为chanrecv()<br>有等待的G,且无缓存时，从G接收<br>有等待的G,且有缓存时，从缓存接收<br>无等待的G,且缓存有数据，从缓存接收<br>无等待的G,且缓存无数据，等待喂数据</p>
</blockquote>
<h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><h2 id="goroutine-per-connection-编程风格"><a href="#goroutine-per-connection-编程风格" class="headerlink" title="goroutine-per-connection 编程风格"></a>goroutine-per-connection 编程风格</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TcpServer.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ln, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := ln.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每个Client一个Goroutine</span></span><br><span class="line">        <span class="keyword">go</span> handleConnection(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    <span class="keyword">var</span> body [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line">    addr := conn.RemoteAddr()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 读取客户端消息</span></span><br><span class="line">        _, err := conn.Read(body[:])</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;收到%s消息: %s\n&quot;</span>, addr, <span class="type">string</span>(body[:]))</span><br><span class="line">        <span class="comment">// 回包</span></span><br><span class="line">        _, err = conn.Write(body[:])</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;发送给%s: %s\n&quot;</span>, addr, <span class="type">string</span>(body[:]))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;与%s断开!\n&quot;</span>, addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p><strong>Socket</strong></p>
<p>很多语言都停供了TCP函数，但是要开发者自己去留意三次握手和四次挥手太过麻烦了，所以很多系统都提供Socket作为TCP网络连接的抽象（平时用到的网络编程实际上基本都是操作Socket）。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230901225708982.png" alt="image-20230901225708982" style="zoom:67%;" />

<blockquote>
<p><strong>IO模型</strong><br>IO模型指的是同时操作Socket的方案——<br>◆阻塞<br>◆非阻塞<br>◆多路复用</p>
</blockquote>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903142920702.png" alt="image-20230903142920702" style="zoom: 67%;" />

<ul>
<li>同步读写Socket时，线程陷入内核态（每个线程都会因为没有客户端数据而阻塞，阻塞就是内核态）</li>
<li>当读写成功后，切换回用户态，继续执行</li>
<li>优点：开发难度小，代码简单</li>
<li>缺点：内核态切换开销大</li>
</ul>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903143107615.png" alt="image-20230903143107615" style="zoom: 67%;" />

<ul>
<li>如果暂时无法收发数据，会返回错误</li>
<li>应用会不断轮询，直到Socket可以读写</li>
<li>优点：不会陷入内核态，自由度高</li>
<li>缺点：需要自旋轮询</li>
</ul>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903143153980.png" alt="image-20230903143153980" style="zoom:67%;" />

<p>epoll全称event poll（有时叫事件池，poll不是池子的意思），我们监听的任务交给操作系统。我们会非阻塞地去epoll获取可读事件（的列表），从而操作对应的socket。</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903165035802.png" alt="image-20230903165035802"></p>
<ul>
<li>注册多个Socket事件</li>
<li>调用epool,当有事件发生，返回</li>
<li>优点：提供了事件列表，不需要查询各个Scoket</li>
<li>缺点：开发难度大，逻辑复杂</li>
</ul>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903143403385.png" alt="image-20230903143403385" style="zoom:50%;" />

<h2 id="Go网络编程"><a href="#Go网络编程" class="headerlink" title="Go网络编程"></a>Go网络编程</h2><p>有没有能结合阻塞模型和多路复用的方法？</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903143439273.png" alt="image-20230903143439273" style="zoom: 80%;" />

<blockquote>
<p><strong>阻塞模型+多路复用</strong><br>在底层使用操作系统的多路复用IO<br>在协程层次使用阻塞模型<br>阻塞协程时，休眠协程</p>
</blockquote>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903143806363.png" alt="image-20230903143806363" style="zoom:67%;" />

<p>（协程的休眠不必进入内核态）</p>
<p>首先为了适应不同系统，需要对epoll进行抽象。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903160423746.png" alt="image-20230903160423746" style="zoom:67%;" />

<p>epoll、IOPC、Kqueue分别是Linux、window、Mac对多路复用的系统工具</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903145239020.png" alt="image-20230903145239020" style="zoom: 40%;" /><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903144554556.png" alt="image-20230903144554556" style="zoom: 45%;" /></p>
<p>netpoll是go的工具，epoll是其在linux的底层实现。</p>
<p><strong>golang对于epoll的抽象，因为我对epoll还没了解，因此还是得后续再去看一些文章。</strong>比如 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/344581947">epoll在Golang的应用 - 知乎 (zhihu.com)</a></p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903170749361.png" alt="image-20230903170749361" style="zoom:50%;" />

<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903170059177.png" alt="image-20230903170059177" style="zoom: 40%;" /><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903165338102.png" alt="image-20230903165338102" style="zoom: 40%;" /></p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903170316260.png" alt="image-20230903170316260" style="zoom:50%;" />

<p>调<code>conn.Read</code>被阻塞是被卡在底层的<code>WaitRead()</code>上。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230903170422509.png" alt="image-20230903170422509" style="zoom:67%;" />

<p>“goroutine-per-connection编程风格”：</p>
<ol>
<li>用主协程监听Listener</li>
<li>每个Conn使用一个新协程处理</li>
<li><strong>结合了多路复用的性能和阻塞模型的简洁</strong></li>
</ol>
<h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><h2 id="9-1-节代码"><a href="#9-1-节代码" class="headerlink" title="9-1 节代码"></a>9-1 节代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    sum = a + b</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">3</span></span><br><span class="line">    b := <span class="number">5</span></span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        sum(a, b)</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902171608399.png" alt="image-20230902171608399" style="zoom: 50%;" />

<p>Go的协程栈是从Go的堆内存上申请的，栈的释放也是通过GC释放的。（C语言中，栈空间和堆空间严格分开，而Go是包含关系）</p>
<p><strong>栈的结构（重点）</strong></p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902163034362.png" alt="image-20230902163034362"></p>
<p>每个栈帧的第一个元素是上一个栈帧的基址，这样以便栈指针回退。</p>
<p>注意顺序，先进入sum的栈帧再进入print。在调用sum前会拷贝实参给形参（可见go是值传递的），同时预留一块内存以接收返回值。通过“返回后的指令”可以继续调研print</p>
<blockquote>
<p>协程栈不够大怎么办？<br>◆局部变量太大（逃逸分析）<br>◆栈帧太多（栈扩容）</p>
</blockquote>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902162704591.png" alt="image-20230902162704591" style="zoom:50%;" />



<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902162906830.png" alt="image-20230902162906830" style="zoom:40%;" /><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902162843420.png" alt="image-20230902162843420" style="zoom:40%;" /></p>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><ul>
<li>函数返回了对象的指针</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Demo <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createDemo</span><span class="params">(name <span class="type">string</span>)</span></span> *Demo &#123;</span><br><span class="line">    d := <span class="built_in">new</span>(Demo) <span class="comment">// 局部变量 d 逃逸到堆</span></span><br><span class="line">    d.name = name</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    demo := createDemo(<span class="string">&quot;demo&quot;</span>)</span><br><span class="line">    fmt.Println(demo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指针逃逸：函数返回了对象的指针</p>
<p>空接口逃逸：<br>如果函数参数为interface{}<br>函数的实参很可能会逃逸<br>因为interface{}类型的函数往往会使用反射（就是在被调用的函数里可能会去分析实参的结构，而这种分析对堆对象更容易）（尤其是使用fmt包时，打印对象往往要通过反射分析其字段。可以改用log包来打印信息）</p>
<p>大变量逃逸：<br>过大的变量会导致栈空间不足<br>64位机器中，一般超过64KB的变量会逃逸</p>
<h2 id="Go的堆结构"><a href="#Go的堆结构" class="headerlink" title="Go的堆结构"></a>Go的堆结构</h2><blockquote>
<p><strong>heapArena</strong><br>Go每次申请的虚拟内存单元为64MB<br>最多有4,194,304个虚拟内存单元（2^20)<br>内存单元t也叫heapArena<br>所有的heapArena组成了mheap(Go堆内存)</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902165050462.png" alt="image-20230902165050462"></p>
<p>（2^20乘以64MB恰好就是256TB（64位机的虚拟内存空间），这是特别设计的，当然了申请太多会被操作系统给kill掉）</p>
<p>描述堆内存的结构体——</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902165240324.png" alt="image-20230902165240324"></p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902165315508.png" alt="image-20230902165315508"></p>
<p>线性分配或链表分配的问题：</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902172630776.png" alt="image-20230902172630776" style="zoom:50%;" />

<p>分级分配思想：</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902172716267.png" alt="image-20230902172716267" style="zoom:50%;" />

<p>这个“级”，我们成为span。</p>
<blockquote>
<p><strong>内存管理单元mspan</strong><br>根据隔离适应策略，使用内存时的最小单位为mspan<br>每个mspan为N个相同大小的“格子”<br>Go中一共有67种mspan（后续提到68是因为多了一种0级）</p>
</blockquote>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902172926419.png" alt="image-20230902172926419" style="zoom:50%;" />

<p>在前文的<code>mheap</code>结构体中，可以看见<code>mspan</code>数组。</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902173057304.png" alt="image-20230902173057304"></p>
<p>每种mspan并不是一开始就分好的，而是需要时再分配。**<code>mspan</code>不是按级别顺序挨在一起的**，可能是分散在不同的heapArena中。</p>
<p>那么，在分配内存时，难道需要遍历每个heapArena去寻找合适的<code>mspan</code>吗？</p>
<blockquote>
<p><strong>中心索引mcentral</strong><br>136个mcentral结构体，其中<br>68个组需要GC扫描的mspan<br>68个组不需要GC扫描的mspan（比如常量）</p>
</blockquote>
<p>专门开辟一片内存空间作为中心索引。<code>mcentral</code>结构体实际上是一个链表头。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902173707749.png" alt="image-20230902173707749" style="zoom:70%;" />

<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902174020293.png" alt="image-20230902174020293"></p>
<p>这样就可以到中心索引中去找最适合的<code>mcentral</code>，进一步找到适合的<code>mspan</code>了。</p>
<p>但是，如果一个<code>mcentral</code>正被一个线程操作，那么就得加锁，这样就不符合高并发场景。因此参考GMP进一步做设计——</p>
<blockquote>
<p><strong>线程缓存ncache</strong><br>每个P（就是GMP的p结构体）拥有一个mcache<br>一个mcache拥有136个mspan,其中<br>68个需要GC扫描的mspan<br>68个不需要GC扫描的mspan</p>
</blockquote>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902174840085.png" alt="image-20230902174840085" style="zoom:80%;" />

<p>线程直接用所对应的p结构体的mcache就好了。当mcache中某个级别的span满了以后，就会去中心索引中再换取一个。</p>
<p><strong>总结</strong></p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902174817311.png" alt="image-20230902174817311" style="zoom:50%;" />



<h2 id="Go的堆内存分配"><a href="#Go的堆内存分配" class="headerlink" title="Go的堆内存分配"></a>Go的堆内存分配</h2><p>Go将对象按照大小分为3种    <img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902181844190.png" alt="image-20230902181844190" style="zoom:50%;" /></p>
<p>微小对象使用普通mcache</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902181955712.png" alt="image-20230902181955712" style="zoom:50%;" />

<p>mcache中，每个级别的mspan只有一个。当mpan满了之后，会从mcentral中换一个新的</p>
<p>mcentral中，只有有限数量的mspan，当mspan缺少时，会从neapArena开辟新的mspan</p>
<p>当neapArena空间不足时，向操作系统申请新的heapArena（<strong>扩容</strong>）</p>
<p><strong>大对象</strong>：直接从neapArena开辟0级的mspan，0级的mspan为大对象定制，可大可小。</p>
<h2 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h2><p>三种回收方式</p>
<ul>
<li>标记-清除（最简单直接，Go所使用）（标记为已删除后，下次gc时回收）</li>
<li>标记-整理</li>
<li>标记-复制</li>
</ul>
<p>GC思路：找到有引用的对象，剩下的就是没有引用的</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902203933121.png" alt="image-20230902203933121" style="zoom:50%;" />

<p>结构体中可能还有指向其他对象的指针，因此要做<strong>可达性分析</strong>：</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902204036684.png" alt="image-20230902204036684" style="zoom:50%;" />

<p>（上图有误，应该是BFS）对到达不了的变量做标记，此过程中必须暂停其他业务，也就是<strong>串行GC</strong></p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902204200364.png" alt="image-20230902204200364" style="zoom:50%;" />



<p><em><strong>三色标记法</strong></em></p>
<ul>
<li>黑色：有用，已经分析扫描</li>
<li>灰色：有用，还未分析扫描</li>
<li>白色：暂时无用</li>
</ul>
<p>基本过程——</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902204514924.png" alt="image-20230902204514924" style="zoom:67%;" />

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902204610082.png" alt="image-20230902204610082" style="zoom:67%;" />

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902204644693.png" alt="image-20230902204644693" style="zoom:67%;" />

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902204658907.png" alt="image-20230902204658907" style="zoom:67%;" />

<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902204719632.png" alt="image-20230902204719632" style="zoom:67%;" />



<p>解决并发问题的策略——<strong>混合标记（删除屏障+插入屏障）</strong></p>
<ul>
<li>被删除的堆对象标记为灰色（快照标记）</li>
<li>被添加的堆对象标记为灰色</li>
</ul>
<p>如下图，B-&gt;C被删除，然后添加E-&gt;C，因为有删除屏障，所以C不会被误删除。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902204803765.png" alt="image-20230902204803765" style="zoom:67%;" />

<p>如下图，只是添加E-&gt;C，但是E已是黑色，导致C被误清除。因此引入了插入屏障。</p>
<img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902204923889.png" alt="image-20230902204923889" style="zoom:67%;" />



<h2 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h2><blockquote>
<p><strong>GC触发时机</strong><br>系统定时触发<br>用户显式触发<br>申请内存时触发</p>
</blockquote>
<p>（1）系统定时触发<br>sysmon定时检查<br>如果2分钟内没有过GC，强制触发<br>谨慎调整</p>
<p>（2）用户显式触发<br>用户调用runtime.GC方法<br>并不推荐调用</p>
<p>（3）申请内存时触发</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902202153276.png" alt="image-20230902202153276"></p>
<p>可见干预触发是不现实的。我们要做的就是<strong>尽量少在堆上产生垃圾</strong>。</p>
<ul>
<li><strong>内存池化</strong></li>
<li><strong>减少逃逸</strong></li>
<li><strong>使用空结构体</strong></li>
</ul>
<h2 id="GC分析工具"><a href="#GC分析工具" class="headerlink" title="GC分析工具"></a>GC分析工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool trace</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags=”-m”</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GODEBUG=”gctrace=1”</span><br></pre></td></tr></table></figure>

<p>执行<code>$env:GODEBUG=&quot;gctrace=1&quot;</code>，之后运行程序。一条打印信息如下：</p>
<p><img src="/images/loading.gif" data-original="/images/typora-user-images/image-20230902203057942.png" alt="image-20230902203057942"></p>
<p><code>@0.011s</code>表示此次gc发生的时刻（自程序启动后），<code>4%</code>表示gc占用时间在程序运行中的占比（虽说gc可以并发，但有些任务是不能并发的）。<code>4-&gt;6-&gt;5MB</code>表示gc前、中、后的堆内存。</p>
<p>gc占比超过<code>10%</code>时，最好去做一下优化。</p>
<h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><h2 id="cgo"><a href="#cgo" class="headerlink" title="cgo"></a>cgo</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int sum(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">  return a+b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(C.sum(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-2节代码"><a href="#10-2节代码" class="headerlink" title="10-2节代码"></a>10-2节代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer1&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dosomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;do something2&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    dosomething()</span><br><span class="line">    fmt.Println(<span class="string">&quot;do something1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="panic基本使用"><a href="#panic基本使用" class="headerlink" title="panic基本使用"></a>panic基本使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dosomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;do something2&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> dosomething()</span><br><span class="line">    fmt.Println(<span class="string">&quot;do something1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="panic-defer"><a href="#panic-defer" class="headerlink" title="panic + defer"></a>panic + defer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dosomething</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;do something2&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    dosomething()</span><br><span class="line">    fmt.Println(<span class="string">&quot;do something1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>panic在退出协程之前会执行所有已注册的defer</li>
</ul>
<h2 id="panic-defer-recover"><a href="#panic-defer-recover" class="headerlink" title="panic + defer + recover"></a>panic + defer + recover</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dosomething</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Recovered. Error:\n&quot;</span>, r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;panic1&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;do something2&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer1&quot;</span>)</span><br><span class="line"></span><br><span class="line">	dosomething()</span><br><span class="line">	fmt.Println(<span class="string">&quot;do something1&quot;</span>)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象到反射对象"><a href="#对象到反射对象" class="headerlink" title="对象到反射对象"></a>对象到反射对象</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;moody&quot;</span></span><br><span class="line"></span><br><span class="line">	stype := reflect.TypeOf(s)</span><br><span class="line">	fmt.Println(<span class="string">&quot;TypeOf s:&quot;</span>, stype)</span><br><span class="line"></span><br><span class="line">	svalue := reflect.ValueOf(s)</span><br><span class="line">	fmt.Println(<span class="string">&quot;ValueOf s:&quot;</span>, svalue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="反射对象到对象"><a href="#反射对象到对象" class="headerlink" title="反射对象到对象"></a>反射对象到对象</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;moody&quot;</span></span><br><span class="line"></span><br><span class="line">    stype := reflect.TypeOf(s)</span><br><span class="line">    fmt.Println(<span class="string">&quot;TypeOf s:&quot;</span>, stype)</span><br><span class="line"></span><br><span class="line">    svalue := reflect.ValueOf(s)</span><br><span class="line">    fmt.Println(<span class="string">&quot;ValueOf s:&quot;</span>, svalue)</span><br><span class="line"></span><br><span class="line">    s2 := svalue.Interface().(<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;s2:&quot;</span>, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发射调用方法"><a href="#发射调用方法" class="headerlink" title="发射调用方法"></a>发射调用方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyAdd</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallAdd</span><span class="params">(f <span class="keyword">func</span>(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">	v := reflect.ValueOf(f)</span><br><span class="line">	<span class="keyword">if</span> v.Kind() != reflect.Func &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	argv := <span class="built_in">make</span>([]reflect.Value, <span class="number">2</span>)</span><br><span class="line">	argv[<span class="number">0</span>] = reflect.ValueOf(<span class="number">1</span>)</span><br><span class="line">	argv[<span class="number">1</span>] = reflect.ValueOf(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	result := v.Call(argv)</span><br><span class="line"></span><br><span class="line">	fmt.Println(result[<span class="number">0</span>].Int())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	CallAdd(MyAdd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/">课堂笔记</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/Golang.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/29/Golang%E4%B9%8BServerMux/" title="Golang之ServerMux"><img class="cover" src="/images/loading.gif" data-original="/images/cover/Golang.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Golang之ServerMux</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84-25/" title="MySQL是怎样运行的:(25)锁"><img class="cover" src="/images/loading.gif" data-original="/images/cover/MySQL.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL是怎样运行的:(25)锁</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/10/29/Golang%E4%B9%8BServerMux/" title="Golang之ServerMux"><img class="cover" src="/images/loading.gif" data-original="/images/cover/Golang.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">Golang之ServerMux</div></div></a></div><div><a href="/2023/10/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BClickHouse-%E5%88%9D%E5%AD%A6/" title="【数据库】初学ClickHouse"><img class="cover" src="/images/loading.gif" data-original="/images/cover/ck.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">【数据库】初学ClickHouse</div></div></a></div><div><a href="/2023/10/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84-1/" title="MySQL是怎样运行的:(1)重新认识MySQL"><img class="cover" src="/images/loading.gif" data-original="/images/cover/MySQL.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">MySQL是怎样运行的:(1)重新认识MySQL</div></div></a></div><div><a href="/2023/10/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84-11/" title="MySQL是怎样运行的:(11)连接的原理"><img class="cover" src="/images/loading.gif" data-original="/images/cover/MySQL.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">MySQL是怎样运行的:(11)连接的原理</div></div></a></div><div><a href="/2023/10/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84-10/" title="MySQL是怎样运行的:(10)单表访问方法"><img class="cover" src="/images/loading.gif" data-original="/images/cover/MySQL.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">MySQL是怎样运行的:(10)单表访问方法</div></div></a></div><div><a href="/2023/10/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84-18/" title="MySQL是怎样运行的:(18)InnoDB的Buffer Pool"><img class="cover" src="/images/loading.gif" data-original="/images/cover/MySQL.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">MySQL是怎样运行的:(18)InnoDB的Buffer Pool</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">第三章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">go的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0SSA%E4%B8%AD%E9%97%B4%E7%A0%81%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">查看从代码到SSA中间码的整个过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-Plan9-%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">查看 Plan9 汇编代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Modules"><span class="toc-number">1.4.</span> <span class="toc-text">使用 Modules</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8goproxy-cn%E4%BD%9C%E4%B8%BA%E4%BB%A3%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">使用goproxy.cn作为代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-mod-%E6%96%87%E4%BB%B6%E8%BF%BD%E5%8A%A0"><span class="toc-number">1.6.</span> <span class="toc-text">go.mod 文件追加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-vender-%E7%BC%93%E5%AD%98%E5%88%B0%E6%9C%AC%E5%9C%B0"><span class="toc-number">1.7.</span> <span class="toc-text">go vender 缓存到本地</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Go-Module"><span class="toc-number">1.8.</span> <span class="toc-text">创建 Go Module</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA"><span class="toc-number">1.9.</span> <span class="toc-text">个人</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GO%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">GO是面向对象吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0"><span class="toc-number">2.</span> <span class="toc-text">第四章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.1.</span> <span class="toc-text">基本类型大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACStringHeader"><span class="toc-number">2.2.</span> <span class="toc-text">字符串转StringHeader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.</span> <span class="toc-text">字符串的两种遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">切片的三种创建方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="toc-number">2.5.</span> <span class="toc-text">map的扩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.</span> <span class="toc-text">map的并发问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%89%B9%E7%82%B9"><span class="toc-number">2.7.</span> <span class="toc-text">Go隐式接口特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">2.8.</span> <span class="toc-text">空指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.9.</span> <span class="toc-text">结构体和指针实现接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AF%B9%E9%BD%90"><span class="toc-number">2.10.</span> <span class="toc-text">变量对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E9%95%BF%E5%AF%B9%E9%BD%90"><span class="toc-number">2.11.</span> <span class="toc-text">字长对齐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0"><span class="toc-number">3.</span> <span class="toc-text">第五章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E8%8A%82%E4%BB%A3%E7%A0%81"><span class="toc-number">3.1.</span> <span class="toc-text">5-2节代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.2.</span> <span class="toc-text">协程本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text">协程工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GMP%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">GMP调度模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="toc-number">3.5.</span> <span class="toc-text">协程并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-number">3.6.</span> <span class="toc-text">抢占式调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E5%BC%80%E5%90%AF%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.7.</span> <span class="toc-text">无限开启协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-channel-%E7%9A%84%E7%BC%93%E5%AD%98%E5%8C%BA"><span class="toc-number">3.8.</span> <span class="toc-text">利用 channel 的缓存区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.9.</span> <span class="toc-text">协程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0"><span class="toc-number">4.</span> <span class="toc-text">第六章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Atomic-%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">Atomic 机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sema%E9%94%81"><span class="toc-number">4.2.</span> <span class="toc-text">sema锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">4.3.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E9%A5%A5%E9%A5%BF"><span class="toc-number">4.4.</span> <span class="toc-text">锁饥饿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.5.</span> <span class="toc-text">读写锁的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#waitgroup%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.6.</span> <span class="toc-text">waitgroup的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98"><span class="toc-number">4.7.</span> <span class="toc-text">锁拷贝问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RACE-%E7%AB%9E%E4%BA%89%E6%A3%80%E6%B5%8B"><span class="toc-number">4.8.</span> <span class="toc-text">RACE 竞争检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dead-lock-%E6%A3%80%E6%B5%8B"><span class="toc-number">4.9.</span> <span class="toc-text">dead lock 检测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0"><span class="toc-number">5.</span> <span class="toc-text">第七章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel-%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">Channel 声明方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">Channel 基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">错误用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%8E%E9%80%9A%E4%BF%A1"><span class="toc-number">5.4.</span> <span class="toc-text">内存与通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E5%8F%97"><span class="toc-number">5.5.</span> <span class="toc-text">发送和接受</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0"><span class="toc-number">6.</span> <span class="toc-text">第八章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#goroutine-per-connection-%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC"><span class="toc-number">6.1.</span> <span class="toc-text">goroutine-per-connection 编程风格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">IO模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">6.3.</span> <span class="toc-text">Go网络编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0"><span class="toc-number">7.</span> <span class="toc-text">第九章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E8%8A%82%E4%BB%A3%E7%A0%81"><span class="toc-number">7.1.</span> <span class="toc-text">9-1 节代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">7.2.</span> <span class="toc-text">逃逸分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E7%9A%84%E5%A0%86%E7%BB%93%E6%9E%84"><span class="toc-number">7.3.</span> <span class="toc-text">Go的堆结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">7.4.</span> <span class="toc-text">Go的堆内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">7.5.</span> <span class="toc-text">GC垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E4%BC%98%E5%8C%96"><span class="toc-number">7.6.</span> <span class="toc-text">GC优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">7.7.</span> <span class="toc-text">GC分析工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0"><span class="toc-number">8.</span> <span class="toc-text">第十章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cgo"><span class="toc-number">8.1.</span> <span class="toc-text">cgo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2%E8%8A%82%E4%BB%A3%E7%A0%81"><span class="toc-number">8.2.</span> <span class="toc-text">10-2节代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#panic%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">8.3.</span> <span class="toc-text">panic基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#panic-defer"><span class="toc-number">8.4.</span> <span class="toc-text">panic + defer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#panic-defer-recover"><span class="toc-number">8.5.</span> <span class="toc-text">panic + defer + recover</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%B0%E5%8F%8D%E5%B0%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.6.</span> <span class="toc-text">对象到反射对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%AF%B9%E8%B1%A1%E5%88%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.7.</span> <span class="toc-text">反射对象到对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B0%84%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.8.</span> <span class="toc-text">发射调用方法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BClickHouse-%E5%88%9D%E5%AD%A6/" title="【数据库】初学ClickHouse"><img src="/images/loading.gif" data-original="/images/cover/ck.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据库】初学ClickHouse"/></a><div class="content"><a class="title" href="/2023/10/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BClickHouse-%E5%88%9D%E5%AD%A6/" title="【数据库】初学ClickHouse">【数据库】初学ClickHouse</a><time datetime="2023-10-29T14:39:24.000Z" title="发表于 2023-10-29 22:39:24">2023-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/29/%E5%86%B0%E9%BE%99%E8%8D%89%E7%9A%84%E5%9B%BE%E8%AE%BA%E7%AC%94%E8%AE%B0/" title="冰龙草的图论笔记"><img src="/images/loading.gif" data-original="/images/cover/icegrass.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="冰龙草的图论笔记"/></a><div class="content"><a class="title" href="/2023/10/29/%E5%86%B0%E9%BE%99%E8%8D%89%E7%9A%84%E5%9B%BE%E8%AE%BA%E7%AC%94%E8%AE%B0/" title="冰龙草的图论笔记">冰龙草的图论笔记</a><time datetime="2023-10-29T14:35:32.000Z" title="发表于 2023-10-29 22:35:32">2023-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/29/%E5%86%B0%E9%BE%99%E8%8D%89%E7%9A%84%E7%AE%97%E6%B3%95%E9%9A%8F%E7%AC%94/" title="冰龙草的算法随笔"><img src="/images/loading.gif" data-original="/images/cover/icegrass.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="冰龙草的算法随笔"/></a><div class="content"><a class="title" href="/2023/10/29/%E5%86%B0%E9%BE%99%E8%8D%89%E7%9A%84%E7%AE%97%E6%B3%95%E9%9A%8F%E7%AC%94/" title="冰龙草的算法随笔">冰龙草的算法随笔</a><time datetime="2023-10-29T14:31:56.000Z" title="发表于 2023-10-29 22:31:56">2023-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%B0%A2%E5%B8%8C%E4%BB%81-%E7%AC%94%E8%AE%B0%E6%A2%B3%E7%90%86/" title="计算机网络(谢希仁)笔记梳理"><img src="/images/loading.gif" data-original="/images/cover/network.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络(谢希仁)笔记梳理"/></a><div class="content"><a class="title" href="/2023/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%B0%A2%E5%B8%8C%E4%BB%81-%E7%AC%94%E8%AE%B0%E6%A2%B3%E7%90%86/" title="计算机网络(谢希仁)笔记梳理">计算机网络(谢希仁)笔记梳理</a><time datetime="2023-10-29T14:29:05.000Z" title="发表于 2023-10-29 22:29:05">2023-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/29/%E3%80%90ACM%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="【ACM】最短路的个人总结"><img src="/images/loading.gif" data-original="/images/cover/acm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【ACM】最短路的个人总结"/></a><div class="content"><a class="title" href="/2023/10/29/%E3%80%90ACM%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="【ACM】最短路的个人总结">【ACM】最短路的个人总结</a><time datetime="2023-10-29T14:26:27.000Z" title="发表于 2023-10-29 22:26:27">2023-10-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Blover</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>